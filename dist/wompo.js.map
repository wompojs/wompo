{
  "version": 3,
  "sources": ["../ts/wompo.ts"],
  "sourcesContent": ["/**\n * False to get smallest build file possible.\n */\nconst DEV_MODE = false;\n\n/* \n================================================\nTYPES\n================================================\n*/\n/**\n * The html`` template function result type.\n */\nexport interface RenderHtml {\n\tparts: TemplateStringsArray;\n\tvalues: any[];\n\t_$wompoHtml: true;\n}\n\n/**\n * The props of any component.\n */\nexport interface WompoProps {\n\t/** The children of the component instance */\n\tchildren?: WompoChildren;\n\t/** The styles generated from the CSS provided */\n\tstyles?: { [key: string]: string };\n\t/** In DEV_MODE, will write on the console performance informations. */\n\t['wc-perf']?: boolean;\n\twcPerf?: boolean;\n\t/** The style of a component to customize it through the style attribute in the DOM. */\n\tstyle?: string | Partial<CSSStyleDeclaration> | object;\n\t/** A potential reference to the element. */\n\tref?: RefHook<any>;\n\t/** The ID of the element */\n\tid?: string;\n\t/** The classes of the element */\n\tclass?: string;\n\t/** JSX events */\n\t[event: `on${string}`]: (ev: Event) => void;\n}\n\n/**\n * The options that a component can have when instantiating.\n * The current available options are:\n * - `name` (string)\n * - `shadow` (boolean)\n * - `cssModule` (boolean)\n */\nexport interface WompoComponentOptions {\n\t/**\n\t * Default value: `null`.\n\t * The component name. If not defined, the component name will be the name of the function in\n\t * hyphen-case. If the component doesn't have an hyphen, a \"wompo\" string will be placed as a\n\t * suffix.\n\t * E.g. TabPanel = tab-panel, Counter = counter-wompo\n\t */\n\tname?: string;\n\t/**\n\t * Default value: `false`. If true, the component will be rendered in a shadow DOM.\n\t */\n\tshadow?: boolean;\n\t/**\n\t * Default value: `true`. If true, the CSS of the component will be replaced with a more unique\n\t * CSS. This is done by simply putting the component name as a prefix in every class.\n\t * The generated class names will be put in the [styles] prop of the component.\n\t * This is done to avoid styles collisions.\n\t * E.g. CounterComponent.css = `.button` => .counter-component__button\n\t */\n\tcssModule?: boolean;\n}\n\n/**\n * The type of the function to create a Wompo Component.\n * It can have a custom `css` property, corresponding to the specific styles of the component.\n */\nexport interface WompoComponent<Props extends WompoProps = WompoProps> {\n\t/** The props of the component */\n\t(props: Props): RenderHtml;\n\t/**\n\t * The specific styles of the component.\n\t */\n\tcss?: string;\n\t/** The component name, elaborated in the defineWompo function */\n\tcomponentName?: string;\n\t/** Identifies the component */\n\t_$wompoF?: true;\n\t/** The generated class of the component */\n\tclass?: WompoElementClass<Props>;\n\t/** Options */\n\toptions?: {\n\t\tgeneratedCSS: string;\n\t\tstyles: { [key: string]: string };\n\t\tshadow: boolean;\n\t};\n}\n\n/**\n * The type of a Wompo component Instance.\n * The public accessible properties are:\n * - `hooks`: Hook[]\n * - `props`: WompoProps\n *\n * The public accessible methods are:\n * - `requestRender()`\n * - `onDisconnected()`\n * - `updateProp(prop, newValue)`\n */\nexport type WompoElement<Props extends WompoProps = WompoProps, E = {}> = HTMLElement &\n\tE & {\n\t\t/**\n\t\t * The props of the component, that are then passed in the function.\n\t\t */\n\t\tprops: Props;\n\n\t\t/**\n\t\t * The hooks of the component. They are accessed by the position in the array.\n\t\t */\n\t\thooks: Hook[];\n\n\t\t/**\n\t\t * The initial props of a component. This property is only used internally when\n\t\t * using a dyanmic tag.\n\t\t */\n\t\t_$initialProps: WompoProps;\n\n\t\t/**\n\t\t * True if the component wants to log the rendering time in the console. Only\n\t\t * available in DEV_MODE.\n\t\t * This property is set to true only when a component has the attribute or\n\t\t * initial prop [wc-perf].\n\t\t */\n\t\t_$measurePerf: boolean;\n\n\t\t/**\n\t\t * True if the component uses a context.\n\t\t */\n\t\t_$usesContext: boolean;\n\n\t\t/**\n\t\t * True if the component has recently been moved. Used to know if a component should search\n\t\t * again for parent contexts.\n\t\t */\n\t\t_$hasBeenMoved: boolean;\n\n\t\t/**\n\t\t * A list of layout effects to execute immediately after the component has been rendered (not\n\t\t * asynchronously).\n\t\t */\n\t\t_$layoutEffects: EffectHook[];\n\n\t\t/**\n\t\t * Requests a render to the component.\n\t\t * @returns void\n\t\t */\n\t\trequestRender: () => void;\n\n\t\t/**\n\t\t * A callback that gets executed whenever the component id disconnected\n\t\t * **definitely** from the DOM. This callback is not called when the\n\t\t * component is just moved from one node to another.\n\t\t * @returns void\n\t\t */\n\t\tonDisconnected: () => void;\n\n\t\t/**\n\t\t * Update a [prop] of the component with the [newValue]. It automatically\n\t\t * re-render the component if the old value and the new value differs.\n\t\t * @param prop The prop name to update\n\t\t * @param newValue The new value to put in the prop\n\t\t * @returns void\n\t\t */\n\t\tupdateProp: (prop: string, newValue: any) => void;\n\n\t\t/**\n\t\t * An identifier to rapidly know if a node is a wompo component.\n\t\t */\n\t\t_$wompo: true;\n\t};\n\n/** The possible hooks that a component can have. */\nexport type Hook =\n\t| StateHook<any>\n\t| EffectHook\n\t| RefHook<any>\n\t| CallbackHook\n\t| IdHook\n\t| MemoHook<any>\n\t| ReducerHook<any>\n\t| AsyncHook<any>\n\t| ContextHook;\n\n/** The hook generated by the useState function */\nexport type StateHook<S> = [S, (newValue: S | ((oldValue: S) => S)) => void];\n\n/** The hook generated by the useEffect and useLayoutEffect functions */\nexport interface EffectHook {\n\tdependencies: any;\n\tcallback: VoidFunction | (() => VoidFunction);\n\tcleanupFunction: VoidFunction | void;\n}\n\n/** The hook generated by the useRef function */\nexport interface RefHook<V> {\n\tcurrent: V;\n\t__wcRef: true;\n}\n\n/** The hook generated by the useCallback function */\nexport interface CallbackHook {\n\tdependencies?: any[];\n\tvalue: (...args: any[]) => any;\n}\n\n/** The hook generated by the useId function */\nexport type IdHook = string;\n\n/** The hook generated by the useMemo function */\nexport interface MemoHook<T = any> {\n\tdependencies: any[];\n\tvalue: T;\n}\n\ninterface ReducerAction {\n\t[key: string]: any;\n}\n/** The hook generated by the useState function */\nexport type ReducerHook<State> = [State, (action: ReducerAction) => void];\n\n/** The hook generated by the useAsync function */\nexport interface AsyncHook<S> {\n\tdependencies: any[];\n\tvalue: S;\n}\n\n/** The props type of a ContextProvider */\ninterface ContextProviderProps extends WompoProps {\n\tvalue: any;\n}\n/** The exposed values of a ContextProvider */\ninterface ContextProviderExposed {\n\tsubscribers: RefHook<Set<WompoElement>>;\n}\n/** The type of a ContextProvier instance */\nexport type ContextProviderElement = WompoElement<ContextProviderProps, ContextProviderExposed>;\n\n/** The hook generated by the useContext hook */\nexport interface ContextHook {\n\tnode: ContextProviderElement;\n}\n\n/**\n * The type of the class generated by the wompo() function.\n */\ninterface WompoElementClass<Props extends WompoProps, E = {}> {\n\t/** The constructor */\n\tnew (): WompoElement<Props, E>;\n\t/** The cached template data. This is generated only the first time a component renders. */\n\t_$cachedTemplate: CachedTemplate;\n\t/** This function will get or create a new CachedTemplate instance. */\n\t_$getOrCreateTemplate(parts: TemplateStringsArray): CachedTemplate;\n}\n\n/**\n * Each CachedTemplate will generate an array of Dependencies that are metadata to efficientluy\n * update the elements.\n */\ninterface Dependency {\n\t/** The type of the dependency (ATTRIBUTE, NODE, TAG) */\n\ttype: number;\n\t/** The index of the element when walked with the treeWalker */\n\tindex: number;\n\t/** This option is valorized if the type is ATTRIBUTE */\n\tname?: string;\n\t/**\n\t * This option is valorized if the type is ATTRIBUTE and it's a composed attribute.\n\t * (e.g. class=\"button ${'button-primary'}\")\n\t */\n\tattrDynamics?: string;\n}\n\n/**\n * The possible dynamic values: DynamicNode | DynamicAttribute | DynamicTag.\n */\ntype Dynamics = DynamicNode | DynamicAttribute | DynamicTag;\n\n/* \n================================================\nVARIABLES\n================================================\n*/\n/**\n * The current rendering component instance. This is used when creating hooks.\n * This variable is exposed only in the `useHook` hook.\n */\nlet currentRenderingComponent: WompoElement = null;\n/**\n * The current hook index in a component. This is used when creating hooks.\n * This variable is exposed only in the `useHook` hook.\n */\nlet currentHookIndex: number = 0;\n\nconst WC_MARKER = '$wc$';\nconst DYNAMIC_TAG_MARKER = 'wc-wc';\nconst isDynamicTagRegex = /<\\/?$/g;\nconst isAttrRegex = /\\s+([^\\s]*?)=([\"'][^\"']*?)?$/g;\nconst selfClosingRegex = /(<([a-z]*-[a-z]*).*?)\\/?>/gs;\nconst isInsideTextTag = /<(?<tag>script|style|textarea|title])(?!.*?<\\/\\k<tag>)/gi;\nconst onlyTextChildrenElementsRegex = /^(?:script|style|textarea|title)$/i;\n\nconst NODE = 0; // Is a NODE Dependency.\nconst ATTR = 1; // Is an ATTRIBUTE Dependency.\nconst TAG = 2; // Is a TAG Dependency.\n\nconst IS_SERVER = typeof global !== 'undefined';\n\nconst doc = IS_SERVER ? ({ createTreeWalker() {} } as unknown as Document) : document;\n\nconst treeWalker = doc.createTreeWalker(\n\tdoc,\n\t129 // NodeFilter.SHOW_{ELEMENT|COMMENT}\n);\n\nconst mutationAttributesExclusions = ['class', 'style', 'id'];\n\n/* \n================================================\nCLASSES\n================================================\n*/\n/**\n * The CachedTemplate class is used to efficiently render components. The template HTML element is\n * stored here and only cloned when a new component is instantiated.\n */\nclass CachedTemplate {\n\t/**\n\t * The HTML Template element that has all the structure and comments built in to identify dynamic\n\t * elements.\n\t */\n\tpublic template: HTMLTemplateElement;\n\t/**\n\t * The list of metadata dependencies used to know which node/attribute should listen to updates\n\t * when a variable changes.\n\t */\n\tpublic dependencies: Dependency[];\n\n\t/**\n\t * Create a new CachedTemplate instance.\n\t * @param template The HTML Template already elaborated to handle the dynamic parts.\n\t * @param dependencies The metadata dependencies for the template.\n\t */\n\tconstructor(template: HTMLTemplateElement, dependencies: Dependency[]) {\n\t\tthis.template = template;\n\t\tthis.dependencies = dependencies;\n\t}\n\n\t/**\n\t * This function will clone the template content and build the dynamcis metadata - an array\n\t * containing all the information to efficiently put values in the DOM, without checking if each\n\t * node is equal to a virtual one. The DOM update is not done through this function, but thanks to\n\t * the `__setValues` function.\n\t * @returns An array containing 2 values: The DOM fragment cloned from the content of the\n\t * template, and the dynamics metadata.\n\t */\n\tpublic clone(): [DocumentFragment, Dynamics[]] {\n\t\tconst content = this.template.content;\n\t\tconst dependencies = this.dependencies;\n\t\tconst fragment = document.importNode(content, true);\n\t\ttreeWalker.currentNode = fragment;\n\t\tlet node = treeWalker.nextNode();\n\t\tlet nodeIndex = 0;\n\t\tlet dynamicIndex = 0;\n\t\tlet templateDependency = dependencies[0];\n\t\tconst dynamics = [];\n\t\twhile (templateDependency !== undefined) {\n\t\t\tif (nodeIndex === templateDependency.index) {\n\t\t\t\tlet dynamic: Dynamics;\n\t\t\t\tconst type = templateDependency.type;\n\t\t\t\tif (type === NODE) {\n\t\t\t\t\tdynamic = new DynamicNode(node as HTMLElement, node.nextSibling);\n\t\t\t\t} else if (type === ATTR) {\n\t\t\t\t\tdynamic = new DynamicAttribute(node as HTMLElement, templateDependency);\n\t\t\t\t} else if (type === TAG) {\n\t\t\t\t\tdynamic = new DynamicTag(node as HTMLElement);\n\t\t\t\t}\n\t\t\t\tdynamics.push(dynamic);\n\t\t\t\ttemplateDependency = dependencies[++dynamicIndex];\n\t\t\t}\n\t\t\tif (nodeIndex !== templateDependency?.index) {\n\t\t\t\tnode = treeWalker.nextNode()!;\n\t\t\t\tnodeIndex++;\n\t\t\t}\n\t\t}\n\t\ttreeWalker.currentNode = document;\n\t\treturn [fragment, dynamics];\n\t}\n}\n\n/**\n * This function is used to store dynamic parts of one component that used the value returned by the\n * `html` function. It allows to create kinda the same process of caching used by every component,\n * so a [dynamics] array is build and used to perform updated on the html result.\n */\nclass HtmlProcessedValue {\n\t/** The last values that the html function returned. */\n\tpublic values: any[];\n\t/** The parts of the render value. */\n\tpublic parts: TemplateStringsArray;\n\t/** The Cached template data returned by the `clone` function. */\n\tpublic template: [DocumentFragment, Dynamics[]];\n\n\tconstructor(render: RenderHtml, template: [DocumentFragment, Dynamics[]]) {\n\t\tthis.values = render.values;\n\t\tthis.parts = render.parts;\n\t\tthis.template = template;\n\t}\n}\n\n/**\n * Contains the data about a Dynamic node.\n */\nclass DynamicNode {\n\t/**\n\t * The start node marks the point on where dynamic nodes must be put after.\n\t * It's a static HTML element. Values between the startNode and endNode are known to be dynamic.\n\t */\n\tpublic startNode: ChildNode;\n\t/**\n\t * The end node marks the point on where dynamic nodes must be put before.\n\t * It's a static HTML element. Values between the startNode and endNode are known to be dynamic.\n\t */\n\tpublic endNode: ChildNode | null;\n\n\tpublic isNode: true = true; // For faster access\n\tpublic isAttr: false = false; // For faster access\n\tpublic isTag: false = false; // For faster access\n\n\t/**\n\t * Creates a new DynamicNode instance.\n\t * @param startNode The start node.\n\t * @param endNode The end node.\n\t */\n\tconstructor(startNode: ChildNode, endNode: ChildNode | null) {\n\t\tthis.startNode = startNode;\n\t\tthis.endNode = endNode;\n\t}\n\n\t/**\n\t * Removes all the nodes between the start and the end nodes.\n\t */\n\tpublic clearValue() {\n\t\tlet currentNode = this.startNode.nextSibling;\n\t\twhile (currentNode && currentNode !== this.endNode) {\n\t\t\tcurrentNode.remove();\n\t\t\tcurrentNode = this.startNode.nextSibling;\n\t\t}\n\t}\n\n\t/**\n\t * First removes all the nodes between the start and the end nodes, then it also removes the\n\t * start node and the end node.\n\t */\n\tpublic dispose() {\n\t\tthis.clearValue();\n\t\tthis.startNode.remove();\n\t\tif (this.endNode) this.endNode.remove();\n\t}\n}\n\n/**\n * Contains the data about a dynamic attribute.\n */\nclass DynamicAttribute {\n\t/** The node that owns the dynamic attribute */\n\tpublic node: HTMLElement;\n\t/** The name of the dynamic attribute. */\n\tpublic name: string;\n\t/**\n\t * If an attribute has only some dynamic parts, this property will contain the whole attribute\n\t * structure. E.g. class=\"button ${'hidden'}\".\n\t */\n\tpublic attrStructure: string;\n\n\tpublic isNode: false = false; // For faster access\n\tpublic isAttr: true = true; // For faster access\n\tpublic isTag: false = false; // For faster access\n\n\t/** The callback to execute when an event is fired. */\n\tprivate __callback: (event: Event) => void;\n\t/** True if an event has already been initialized. */\n\tprivate __eventInitialized = false;\n\n\t/**\n\t * Creates a new DynamicAttribute instance.\n\t * @param node The node that owns the attribute.\n\t * @param dependency The dependency metadata.\n\t */\n\tconstructor(node: HTMLElement, dependency: Dependency) {\n\t\tthis.node = node;\n\t\tthis.name = dependency.name;\n\t\tthis.attrStructure = dependency.attrDynamics;\n\t}\n\n\t/**\n\t * Update an attribute value.\n\t * @param newValue The new value of the attribute\n\t */\n\tpublic updateValue(newValue: any) {\n\t\tif (this.name === 'ref' && newValue.__wcRef) {\n\t\t\tnewValue.current = this.node;\n\t\t\treturn;\n\t\t}\n\t\tif (DEV_MODE && (this.name === 'wc-perf' || this.name == 'wcPerf'))\n\t\t\t(this.node as WompoElement)._$measurePerf = true;\n\t\tconst isWompoElement = (this.node as WompoElement)._$wompo;\n\t\tif (isWompoElement) (this.node as WompoElement).updateProp(this.name, newValue);\n\t\tconst isPrimitive = newValue !== Object(newValue);\n\t\tif (newValue === false || newValue === null || newValue === undefined) {\n\t\t\tthis.node.removeAttribute(this.name);\n\t\t} else if (\n\t\t\tisPrimitive &&\n\t\t\t(!this.name.match(/[A-Z]/) || this.node.nodeName === 'svg') &&\n\t\t\tthis.name !== 'title'\n\t\t) {\n\t\t\tthis.node.setAttribute(this.name, newValue);\n\t\t} else if (this.name === 'style') {\n\t\t\tlet styleString = '';\n\t\t\tconst styles = Object.keys(newValue);\n\t\t\tfor (const key of styles) {\n\t\t\t\tlet styleValue = newValue[key];\n\t\t\t\tlet styleKey = key.replace(/[A-Z]/g, (letter) => '-' + letter.toLowerCase());\n\t\t\t\tif (typeof styleValue === 'number') styleValue = `${styleValue}px`;\n\t\t\t\tif (styleValue !== undefined && styleValue !== null && styleValue !== false)\n\t\t\t\t\tstyleString += `${styleKey}:${styleValue};`;\n\t\t\t}\n\t\t\tthis.node.setAttribute(this.name, styleString);\n\t\t}\n\t\tif (this.name === 'title' && isWompoElement) this.node.removeAttribute(this.name);\n\t}\n\n\t/**\n\t * Set the callback function to be executed when an event is fired. If the event has not been\n\t * initialized, the event listener will be added.\n\t */\n\tset callback(callback: (event: Event) => void) {\n\t\tif (!this.__eventInitialized) {\n\t\t\tconst eventName = this.name.substring(1);\n\t\t\tthis.node.addEventListener(eventName, this.__listener.bind(this));\n\t\t\tthis.__eventInitialized = true;\n\t\t}\n\t\tthis.__callback = callback;\n\t}\n\n\t/**\n\t * The listener that will execute the __callback function (if defined).\n\t * @param event The event object\n\t */\n\tprivate __listener(event: Event) {\n\t\tif (this.__callback) this.__callback(event);\n\t}\n}\n\n/**\n * Contains the data about a dynamic tag name.\n */\nclass DynamicTag {\n\t/** The node that has the dynamic tag. */\n\tpublic node: ChildNode;\n\n\tpublic isNode: false = false; // For faster access\n\tpublic isAttr: false = false; // For faster access\n\tpublic isTag: true = true; // For faster access\n\n\t/**\n\t * Creates a new DynamicTag instance.\n\t * @param node The node instance.\n\t */\n\tconstructor(node: ChildNode) {\n\t\tthis.node = node;\n\t}\n}\n\n/**\n * Holds the children of a component. They are stored in an array of nodes instead of an NodeList or\n * HTMLCollection, so that they are not lost and reusable when removed from the DOM.\n */\nclass WompoChildren {\n\tpublic nodes: Node[];\n\n\tpublic _$wompoChildren: true = true;\n\n\tconstructor(nodes: Node[]) {\n\t\tthis.nodes = nodes;\n\t}\n}\n\n/**\n * Hold the informations to efficiently update a dynamic value that is an array.\n */\nclass WompoArrayDependency {\n\t/** A list of dynamic nodes, used to know where each item of the array begins and ends. */\n\tpublic dynamics: DynamicNode[];\n\n\tpublic isArrayDependency: true = true; // For faster access\n\n\t/** The array containing the old values, for comparisons. */\n\tprivate __oldValues: any[];\n\t/** The array containing the old values, not modified by the __setValues function. */\n\tprivate __oldPureValues: any[];\n\t/** The parent dynamic node dependency. */\n\tprivate __parentDependency: DynamicNode;\n\n\t/**\n\t * Creates a new WompoArrayDependency instance.\n\t * @param values The array of values to put in the DOM\n\t * @param dependency The dynamic node dependency on which the array should be rendered.\n\t */\n\tconstructor(values: any[], dependency: DynamicNode) {\n\t\tthis.dynamics = [];\n\t\tthis.__oldValues = [];\n\t\tthis.__parentDependency = dependency;\n\t\tdependency.startNode.after(document.createComment('?wc-end'));\n\t\tthis.addDependenciesFrom(dependency.startNode as HTMLElement, values);\n\t\tthis.__oldPureValues = values;\n\t}\n\n\t/**\n\t * This function will add markers (HTML comments) and generate dynamic nodes dependecies used to\n\t * efficiently udpate the values inside of the array.\n\t * @param startNode The start node on which insert the new \"single-item\" dependencies.\n\t * @param toAdd The values to add\n\t */\n\tprivate addDependenciesFrom(startNode: HTMLElement, toAdd: any[]) {\n\t\tlet currentNode = startNode;\n\t\tfor (let i = 0; i < toAdd.length; i++) {\n\t\t\tconst value = toAdd[i];\n\t\t\tcurrentNode.after(document.createTextNode(''));\n\t\t\tcurrentNode.after(document.createTextNode(''));\n\t\t\tconst dependency = new DynamicNode(\n\t\t\t\tcurrentNode.nextSibling,\n\t\t\t\tcurrentNode.nextSibling.nextSibling\n\t\t\t);\n\t\t\tcurrentNode = currentNode.nextSibling.nextSibling as HTMLElement;\n\t\t\tthis.dynamics.push(dependency);\n\t\t\tthis.__oldValues.push(__setValues([dependency], [value], [])[0]);\n\t\t}\n\t}\n\n\t/**\n\t * Check if there are dependencies to add/remove, and then set the new values to the old nodes.\n\t * Setting the new values will start an eventual recursive check for eventual nested arrays.\n\t * @param newValues The new values to check with the old ones fot updates.\n\t * @returns This instance.\n\t */\n\tpublic checkUpdates(newValues: any[]) {\n\t\tif (newValues === this.__oldPureValues) return this;\n\t\tconst oldValuesLength = this.__oldValues.length;\n\t\tlet diff = newValues.length - oldValuesLength;\n\t\tif (diff < 0) {\n\t\t\twhile (diff) {\n\t\t\t\tconst toClean = this.dynamics.pop();\n\t\t\t\tthis.__oldValues.pop();\n\t\t\t\ttoClean.dispose();\n\t\t\t\tdiff++;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < this.dynamics.length; i++) {\n\t\t\tconst newValue = newValues[i];\n\t\t\tconst dependency = this.dynamics[i];\n\t\t\tconst oldValue = this.__oldValues[i];\n\t\t\tthis.__oldValues[i] = __setValues([dependency], [newValue], [oldValue])[0];\n\t\t}\n\t\tif (diff > 0) {\n\t\t\tlet currentNode = this.dynamics[this.dynamics.length - 1]?.endNode;\n\t\t\tif (!currentNode) currentNode = this.__parentDependency.startNode;\n\n\t\t\tfor (let i = 0; i < diff; i++) {\n\t\t\t\tconst value = newValues[oldValuesLength + i];\n\t\t\t\tcurrentNode.after(document.createTextNode(''));\n\t\t\t\tcurrentNode.after(document.createTextNode(''));\n\t\t\t\tconst dependency = new DynamicNode(\n\t\t\t\t\tcurrentNode.nextSibling,\n\t\t\t\t\tcurrentNode.nextSibling.nextSibling\n\t\t\t\t);\n\t\t\t\tcurrentNode = currentNode.nextSibling.nextSibling as HTMLElement;\n\t\t\t\tthis.dynamics.push(dependency);\n\t\t\t\tthis.__oldValues.push(__setValues([dependency], [value], []));\n\t\t\t}\n\t\t}\n\t\tthis.__oldPureValues = newValues;\n\t\treturn this;\n\t}\n}\n\n/* \n================================================\nSUPPORT FUNCTIONS\n================================================\n*/\n\n/**\n * Generates the static styles of a component. If the `cssModule` option in the component is\n * false, the generation will be skipped and the css will be taken as it is.\n * If the css contains an \":host\" selector, it'll be replaced or kept based on if the shadow option\n * is true, otherwise, a default \"display: block;\" style will be added in the component.\n * @returns an array of 2 values: the first is the generated CSS string, the second is an object\n * having as keys the original class names, and as the value the replaced class names.\n */\nconst __generateSpecifcStyles = (\n\tcomponent: WompoComponent,\n\toptions: WompoComponentOptions\n): [string, { [className: string]: string }] => {\n\tconst { css } = component;\n\tconst { shadow, name, cssModule } = options;\n\tconst componentName = name;\n\tconst classes: { [key: string]: string } = {};\n\tlet generatedCss = css;\n\tif (cssModule) {\n\t\tif (!css.includes(':host'))\n\t\t\tgeneratedCss = `${shadow ? ':host' : componentName} {display:block;} ${css}`;\n\t\tif (DEV_MODE) {\n\t\t\tconst invalidSelectors: string[] = [];\n\t\t\t// It's appropriate that at least one class is present in each selector\n\t\t\t[...generatedCss.matchAll(/.*?}([\\s\\S]*?){/gm)].forEach((selector) => {\n\t\t\t\tconst cssSelector = selector[1].trim();\n\t\t\t\tif (!cssSelector.match(/\\.|:host|@/)) invalidSelectors.push(cssSelector);\n\t\t\t});\n\t\t\tinvalidSelectors.forEach((selector) => {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`The CSS selector \"${selector} {...}\" in the component \"${componentName}\" is not enough` +\n\t\t\t\t\t\t` specific: include at least one class or deactive the \"cssModule\" option on the component.`\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\t\tif (!shadow) generatedCss = generatedCss.replace(/:host/g, componentName);\n\t\tgeneratedCss = generatedCss.replace(/\\.(?!\\d)([_a-zA-Z0-9-]+)/gm, (_, className) => {\n\t\t\tconst uniqueClassName = `${componentName}__${className}`;\n\t\t\tclasses[className] = uniqueClassName;\n\t\t\treturn `.${uniqueClassName}`;\n\t\t});\n\t}\n\treturn [generatedCss, classes];\n};\n\n/**\n * This function will create the valid HTML string to put in a template, used then to create the DOM\n * of a component and obtain the dynamic metadata.\n * @param parts The static parts of the `html` function.\n * @returns An array having 2 values: the generated HTML string, and a list of attribute names that\n * are known to be dynamic.\n */\nconst __createHtml = (parts: TemplateStringsArray): [string, string[]] => {\n\tlet html = '';\n\tconst attributes = [];\n\tconst length = parts.length - 1;\n\tlet attrDelimiter = '';\n\tlet textTagName = '';\n\tfor (let i = 0; i < length; i++) {\n\t\tlet part = parts[i];\n\t\t// End of values inside an attribute\n\t\tif (attrDelimiter && part.includes(attrDelimiter)) attrDelimiter = '';\n\t\t// End of values inside a text node (script, textarea, title, style)\n\t\tif (textTagName && new RegExp(`<\\/${textTagName}>`)) textTagName = '';\n\t\tif (attrDelimiter || textTagName) {\n\t\t\t// We are inside an attribute\n\t\t\thtml += part + WC_MARKER;\n\t\t} else {\n\t\t\t// If the Regex is global, it will start from the index past the end of the last match.\n\t\t\tisAttrRegex.lastIndex = 0;\n\t\t\tconst isAttr = isAttrRegex.exec(part);\n\t\t\tif (isAttr) {\n\t\t\t\tconst [match, attrName] = isAttr;\n\t\t\t\tconst beforeLastChar = match[match.length - 1];\n\t\t\t\tconst delimiter = match.lastIndexOf('\"') > match.lastIndexOf(\"'\") ? '\"' : \"'\";\n\t\t\t\tif (!attrDelimiter) {\n\t\t\t\t\tattrDelimiter = beforeLastChar === '=' ? '' : delimiter;\n\t\t\t\t\tpart = part.replace(/=([^=]*)$/g, (el) => `${WC_MARKER}=${el.substring(1)}`);\n\t\t\t\t\tlet toAdd = part;\n\t\t\t\t\tif (attrDelimiter) toAdd += WC_MARKER;\n\t\t\t\t\telse toAdd += '\"0\"';\n\t\t\t\t\thtml += toAdd;\n\t\t\t\t}\n\t\t\t\tattributes.push(attrName);\n\t\t\t} else {\n\t\t\t\tif (part.match(isDynamicTagRegex)) {\n\t\t\t\t\thtml += part + DYNAMIC_TAG_MARKER;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisInsideTextTag.lastIndex = 0;\n\t\t\t\tconst insideTextTag = isInsideTextTag.exec(part);\n\t\t\t\tif (insideTextTag) {\n\t\t\t\t\ttextTagName = insideTextTag[1];\n\t\t\t\t\thtml += part + WC_MARKER;\n\t\t\t\t} else {\n\t\t\t\t\t// It's a child node\n\t\t\t\t\thtml += part + `<?${WC_MARKER}>`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\thtml += parts[parts.length - 1];\n\thtml = html.replace(selfClosingRegex, (match, firstPart, componentName) => {\n\t\tif (match.endsWith('/>')) return `${firstPart}></${componentName}>`;\n\t\treturn match;\n\t});\n\thtml = html.replace(/<[a-z]*-[a-z]*\\s?.*?>/gms, (match) => {\n\t\treturn match.replace(/(?<=\\s)([a-z]+([A-Z][a-z]*)+)[=\\s]/gms, (attr) =>\n\t\t\tattr.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`)\n\t\t);\n\t});\n\treturn [html, attributes];\n};\n\n/**\n * Based on a template content, this function will extract the dynamic dependecies, and build the\n * metadata used to efficiently update the nodes during re-render.\n * @param template An HTML Template element\n * @param parts The parts returned by the `html` function\n * @param attributes The dynamic attribute names obtained by the `__createHtml` function.\n * @returns The list of elaborated dependencies\n */\nconst __createDependencies = (\n\ttemplate: HTMLTemplateElement,\n\tparts: TemplateStringsArray,\n\tattributes: string[]\n) => {\n\tconst dependencies = [];\n\ttreeWalker.currentNode = template.content;\n\tlet node: Element;\n\tlet dependencyIndex = 0;\n\tlet nodeIndex = 0;\n\tconst partsLength = parts.length;\n\twhile (((node as Node) = treeWalker.nextNode()) !== null && dependencies.length < partsLength) {\n\t\t// Is a \"normal\" node\n\t\tif (node.nodeType === 1) {\n\t\t\tif (node.nodeName === DYNAMIC_TAG_MARKER.toUpperCase()) {\n\t\t\t\tconst dependency: Dependency = {\n\t\t\t\t\ttype: TAG,\n\t\t\t\t\tindex: nodeIndex,\n\t\t\t\t};\n\t\t\t\tdependencies.push(dependency);\n\t\t\t}\n\t\t\tif (node.hasAttributes()) {\n\t\t\t\tconst attributeNames = node.getAttributeNames();\n\t\t\t\tfor (const attrName of attributeNames) {\n\t\t\t\t\tif (attrName.endsWith(WC_MARKER)) {\n\t\t\t\t\t\tconst realName = attributes[dependencyIndex++];\n\t\t\t\t\t\tconst attrValue = node.getAttribute(attrName);\n\t\t\t\t\t\tif (attrValue !== '0') {\n\t\t\t\t\t\t\tconst dynamicParts = attrValue.split(WC_MARKER);\n\t\t\t\t\t\t\tfor (let i = 0; i < dynamicParts.length - 1; i++) {\n\t\t\t\t\t\t\t\tconst dependency: Dependency = {\n\t\t\t\t\t\t\t\t\ttype: ATTR,\n\t\t\t\t\t\t\t\t\tindex: nodeIndex,\n\t\t\t\t\t\t\t\t\tattrDynamics: attrValue,\n\t\t\t\t\t\t\t\t\tname: realName,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tdependencies.push(dependency);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst dependency: Dependency = {\n\t\t\t\t\t\t\t\ttype: ATTR,\n\t\t\t\t\t\t\t\tindex: nodeIndex,\n\t\t\t\t\t\t\t\tname: realName,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tdependencies.push(dependency);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnode.removeAttribute(attrName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// A text node should be created for each dynamic part inside of\n\t\t\t// nodes that only have text nodes inside (script, style, textarea, title).\n\t\t\tif (onlyTextChildrenElementsRegex.test(node.tagName)) {\n\t\t\t\tconst strings = node.textContent!.split(WC_MARKER);\n\t\t\t\tconst lastIndex = strings.length - 1;\n\t\t\t\tif (lastIndex > 0) {\n\t\t\t\t\tnode.textContent = '';\n\t\t\t\t\tfor (let i = 0; i < lastIndex; i++) {\n\t\t\t\t\t\tnode.append(strings[i], document.createComment(''));\n\t\t\t\t\t\t// Walk past the marker node we just added\n\t\t\t\t\t\ttreeWalker.nextNode();\n\t\t\t\t\t\tdependencies.push({ type: NODE, index: ++nodeIndex });\n\t\t\t\t\t}\n\t\t\t\t\t// It's not necessary to adjust nodeIndex here\n\t\t\t\t\tnode.append(strings[lastIndex], document.createComment(''));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (node.nodeType === 8) {\n\t\t\t// Is a comment\n\t\t\tconst data = (node as unknown as Comment).data;\n\t\t\tif (data === `?${WC_MARKER}`) dependencies.push({ type: NODE, index: nodeIndex });\n\t\t}\n\t\tnodeIndex++;\n\t}\n\treturn dependencies;\n};\n\n/**\n * Create a new CachedTemplate, by first obtaining the html content string, and then creating the\n * dependencies. The newly created template will be then used by components of the same type.\n * @param parts The parts returned by the `html` function.\n * @returns a new instance of CachedTemplate\n */\nconst __createTemplate = (html: RenderHtml) => {\n\tconst [dom, attributes] = __createHtml(html.parts);\n\tconst template = document.createElement('template');\n\ttemplate.innerHTML = dom;\n\tconst dependencies = __createDependencies(template, html.parts, attributes);\n\treturn new CachedTemplate(template, dependencies);\n};\n\n/**\n * This function will compare the parts of the new and old template. If one of the parts differs,\n * means the 2 templates are not equal.\n * @param render The whole result of the `html` function\n * @returns The string representation of the the template.\n */\nconst __areSameTemplates = (newTemplate: RenderHtml, oldTemplate: RenderHtml) => {\n\tif (!newTemplate || !oldTemplate) return false;\n\tconst newParts = newTemplate.parts;\n\tconst oldParts = oldTemplate.parts;\n\tif (newParts.length !== oldParts?.length) return false;\n\tconst newValues = newTemplate.values;\n\tconst oldValues = oldTemplate.values;\n\tfor (let i = 0; i < newParts.length; i++) {\n\t\tif (newParts[i] !== oldParts[i]) return false;\n\t\tif (newValues[i]?._$wompoF) {\n\t\t\tif (!oldValues[i]?._$wompoF) return false;\n\t\t\tif (newValues[i].componentName !== oldValues[i].componentName) return false;\n\t\t}\n\t}\n\treturn true;\n};\n\n/**\n * Compare the old value with the new value, and returns true if they differs.\n * @param currentValue The current value\n * @param oldValue The old value\n * @param dependency The dependency that includes the value\n * @returns True if the dependency should be updated\n */\nconst __shouldUpdate = (currentValue: any, oldValue: any, dependency: Dynamics) => {\n\tconst valuesDiffers = currentValue !== oldValue;\n\tconst isComposedAttribute = !!(dependency as DynamicAttribute).attrStructure;\n\tconst isWompoChildren = currentValue?._$wompoChildren;\n\tconst childrenNeedUpdate =\n\t\tisWompoChildren && (dependency as DynamicNode).startNode.nextSibling !== currentValue.nodes[0];\n\treturn valuesDiffers || isComposedAttribute || childrenNeedUpdate;\n};\n\nconst __handleDynamicTag = (\n\tcurrentValue: any,\n\tcurrentDependency: DynamicTag,\n\tvalueIndex: number,\n\tdynamics: Dynamics[],\n\tvalues: any[]\n) => {\n\tconst node = currentDependency.node;\n\tlet customElement: HTMLElement = null;\n\tconst isCustomComponent = currentValue._$wompoF;\n\tconst newNodeName: string = isCustomComponent ? currentValue.componentName : currentValue;\n\tif (node.nodeName !== newNodeName.toUpperCase()) {\n\t\tconst oldAttributes = (node as HTMLElement).getAttributeNames();\n\t\tif (isCustomComponent) {\n\t\t\tconst initialProps: any = {};\n\t\t\tfor (const attrName of oldAttributes) {\n\t\t\t\t// attributes on the dom will be set when creating the element\n\t\t\t\tconst attrValue = (node as HTMLElement).getAttribute(attrName);\n\t\t\t\tlet propName = attrName;\n\t\t\t\tif (propName.includes('-')) propName = propName.replace(/-(.)/g, (_, l) => l.toUpperCase());\n\t\t\t\tinitialProps[propName] = attrValue === '' ? true : attrValue;\n\t\t\t}\n\t\t\tcustomElement = new currentValue.class() as WompoElement;\n\t\t\t(customElement as WompoElement)._$initialProps = initialProps;\n\t\t\t(customElement as WompoElement).props = initialProps;\n\t\t\tconst childNodes = node.childNodes;\n\t\t\twhile (childNodes.length) {\n\t\t\t\tcustomElement.appendChild(childNodes[0]);\n\t\t\t}\n\t\t} else {\n\t\t\t// Is normal element\n\t\t\tcustomElement = document.createElement(newNodeName);\n\t\t\tfor (const attrName of oldAttributes) {\n\t\t\t\tcustomElement.setAttribute(attrName, (node as HTMLElement).getAttribute(attrName));\n\t\t\t}\n\t\t}\n\t\tlet index = valueIndex;\n\t\tlet currentDynamic = dynamics[index] as DynamicAttribute;\n\t\twhile (currentDynamic?.node === node) {\n\t\t\t// Update node pointer of dynamics pointing to the old one.\n\t\t\tcurrentDynamic.node = customElement;\n\t\t\tif (index === valueIndex) {\n\t\t\t\t// Skip first value, which is the dynamic node itself.\n\t\t\t\tindex++;\n\t\t\t\tcurrentDynamic = dynamics[index] as DynamicAttribute;\n\t\t\t} else {\n\t\t\t\t// Set initial props of the correct type, so a number doesn't become a string\n\t\t\t\tif (currentDynamic?.name && currentDynamic?.name !== 'ref') {\n\t\t\t\t\t((customElement as WompoElement)._$initialProps as any)[currentDynamic.name] =\n\t\t\t\t\t\tvalues[index];\n\t\t\t\t\t((customElement as WompoElement).props as any)[currentDynamic.name] = values[index];\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tcurrentDynamic = dynamics[index] as DynamicAttribute;\n\t\t\t}\n\t\t}\n\t\tnode.replaceWith(customElement);\n\t\treturn customElement;\n\t}\n};\n\n/**\n * This function will compare the values of the previous render with the current one, and update the\n * DOM accordingly.\n * This function alters the original [dynamics] array: **it's not pure**.\n * @param dynamics The array of dynamic dependencies\n * @param values The new values of the render\n * @param oldValues The old values used in the previous render\n * @returns A modified version of the new values\n */\nconst __setValues = (dynamics: Dynamics[], values: any[], oldValues: any[]) => {\n\tconst newValues = [...values];\n\tfor (let i = 0; i < dynamics.length; i++) {\n\t\tconst currentDependency = dynamics[i];\n\t\tconst currentValue = newValues[i];\n\t\tconst oldValue = oldValues[i];\n\t\t// Update References\n\t\tif (currentValue?.__wcRef && currentDependency.isAttr && currentDependency.name === 'ref')\n\t\t\tcurrentValue.current = currentDependency.node;\n\t\tif (!__shouldUpdate(currentValue, oldValue, currentDependency))\n\t\t\t// Skip update: values are the same\n\t\t\tcontinue;\n\t\tif (currentDependency.isNode) {\n\t\t\t// Falsy values are cleared from the DOM\n\t\t\tif (currentValue === false || currentValue === undefined || currentValue === null) {\n\t\t\t\tcurrentDependency.clearValue();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (currentValue?._$wompoHtml) {\n\t\t\t\t// handle template elements\n\t\t\t\tconst areTheSame = __areSameTemplates(currentValue, oldValue);\n\t\t\t\tif (oldValue === undefined || !areTheSame) {\n\t\t\t\t\tconst cachedTemplate = __createTemplate(currentValue);\n\t\t\t\t\tconst template = cachedTemplate.clone();\n\t\t\t\t\tconst [fragment, dynamics] = template;\n\t\t\t\t\tnewValues[i] = new HtmlProcessedValue(currentValue, template);\n\t\t\t\t\tnewValues[i].values = __setValues(\n\t\t\t\t\t\tdynamics,\n\t\t\t\t\t\tcurrentValue.values,\n\t\t\t\t\t\toldValue?.values ?? oldValue ?? []\n\t\t\t\t\t);\n\t\t\t\t\tconst startNode = (currentDependency as DynamicNode).startNode;\n\t\t\t\t\tcurrentDependency.clearValue();\n\t\t\t\t\tlet currentNode = startNode;\n\t\t\t\t\twhile (fragment.childNodes.length) {\n\t\t\t\t\t\tcurrentNode.after(fragment.childNodes[0]);\n\t\t\t\t\t\tcurrentNode = currentNode.nextSibling;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet oldTemplateValue = oldValue as HtmlProcessedValue;\n\t\t\t\t\tif (!oldValue.template) {\n\t\t\t\t\t\tconst cachedTemplate = __createTemplate(currentValue);\n\t\t\t\t\t\tconst template = cachedTemplate.clone();\n\t\t\t\t\t\tnewValues[i] = new HtmlProcessedValue(currentValue, template);\n\t\t\t\t\t\toldTemplateValue = newValues[i];\n\t\t\t\t\t}\n\t\t\t\t\tconst [_, dynamics] = oldTemplateValue.template;\n\t\t\t\t\tconst processedValues = __setValues(\n\t\t\t\t\t\tdynamics,\n\t\t\t\t\t\tcurrentValue.values,\n\t\t\t\t\t\t(oldValue as HtmlProcessedValue).values\n\t\t\t\t\t);\n\t\t\t\t\t(oldValue as HtmlProcessedValue).values = processedValues;\n\t\t\t\t\tnewValues[i] = oldValue;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// It's not necessary to check every single node: if a dependency updates,\n\t\t\t// it'll be automatically updated. It's only necessary to update the\n\t\t\t// textContent of primitive values.\n\t\t\tconst isPrimitive = currentValue !== Object(currentValue);\n\t\t\tconst oldIsPrimitive = oldValue !== Object(oldValue) && oldValue !== undefined;\n\t\t\tconst startNode = currentDependency.startNode;\n\t\t\tif (isPrimitive) {\n\t\t\t\tif (oldIsPrimitive) {\n\t\t\t\t\t// At this point there's already a content in the node\n\t\t\t\t\tif (startNode.nextSibling) startNode.nextSibling.textContent = currentValue;\n\t\t\t\t\telse startNode.after(currentValue);\n\t\t\t\t} else {\n\t\t\t\t\tcurrentDependency.clearValue();\n\t\t\t\t\tstartNode.after(currentValue);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet currentNode = startNode.nextSibling;\n\t\t\t\tlet newNodeIndex = 0;\n\t\t\t\tlet index = 0;\n\t\t\t\tif (currentValue._$wompoChildren) {\n\t\t\t\t\tif (oldValue && !oldValue?._$wompoChildren) currentDependency.clearValue();\n\t\t\t\t\tconst childrenNodes = (currentValue as WompoChildren).nodes;\n\t\t\t\t\twhile (index < childrenNodes.length) {\n\t\t\t\t\t\tif (!currentNode || index === 0) currentNode = startNode;\n\t\t\t\t\t\tconst newNode = childrenNodes[newNodeIndex];\n\t\t\t\t\t\tnewNodeIndex++;\n\t\t\t\t\t\tcurrentNode.after(newNode);\n\t\t\t\t\t\tcurrentNode = currentNode.nextSibling;\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (Array.isArray(currentValue)) {\n\t\t\t\t\t\tif (!(oldValue as WompoArrayDependency)?.isArrayDependency) {\n\t\t\t\t\t\t\tcurrentDependency.clearValue();\n\t\t\t\t\t\t\tnewValues[i] = new WompoArrayDependency(currentValue, currentDependency);\n\t\t\t\t\t\t} else newValues[i] = (oldValue as WompoArrayDependency).checkUpdates(currentValue);\n\t\t\t\t\t} else if (DEV_MODE) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Rendering objects is not supported. Please stringify or remove the object.'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (currentDependency.isAttr) {\n\t\t\tconst attrName = currentDependency.name;\n\t\t\tif (attrName.startsWith('@')) {\n\t\t\t\tcurrentDependency.callback = currentValue;\n\t\t\t} else {\n\t\t\t\tconst attrStructure = currentDependency.attrStructure;\n\t\t\t\tif (attrStructure) {\n\t\t\t\t\tconst parts = attrStructure.split(WC_MARKER);\n\t\t\t\t\tlet dynamicValue = currentValue;\n\t\t\t\t\tfor (let j = 0; j < parts.length - 1; j++) {\n\t\t\t\t\t\tconst value =\n\t\t\t\t\t\t\tdynamicValue !== undefined && dynamicValue !== null && dynamicValue !== false\n\t\t\t\t\t\t\t\t? dynamicValue\n\t\t\t\t\t\t\t\t: '';\n\t\t\t\t\t\tparts[j] = `${parts[j]}${value}`;\n\t\t\t\t\t\ti++; // Go to the next dynamic value\n\t\t\t\t\t\tdynamicValue = newValues[i];\n\t\t\t\t\t}\n\t\t\t\t\ti--; // Since it'll be already increased in the loop, decrease by one\n\t\t\t\t\tcurrentDependency.updateValue(parts.join('').trim());\n\t\t\t\t} else {\n\t\t\t\t\tcurrentDependency.updateValue(currentValue);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (currentDependency.isTag) {\n\t\t\tconst isLazy = currentValue._$wompoLazy;\n\t\t\tif (isLazy) {\n\t\t\t\tconst node = currentDependency.node;\n\t\t\t\tconst suspenseNode = findSuspense(node) as SuspenseInstance | null;\n\t\t\t\tif (suspenseNode) {\n\t\t\t\t\tif (suspenseNode.addSuspense) {\n\t\t\t\t\t\tsuspenseNode.addSuspense(node);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsuspenseNode.loadingComponents = new Set();\n\t\t\t\t\t\tsuspenseNode.loadingComponents.add(node);\n\t\t\t\t\t}\n\t\t\t\t\t(node as any).suspense = suspenseNode;\n\t\t\t\t}\n\t\t\t\t// Catch is handled inside the lazy() function.\n\t\t\t\tcurrentValue().then((Component: WompoComponent) => {\n\t\t\t\t\tconst customElement = __handleDynamicTag(\n\t\t\t\t\t\tComponent,\n\t\t\t\t\t\tcurrentDependency,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\tdynamics,\n\t\t\t\t\t\tvalues\n\t\t\t\t\t);\n\t\t\t\t\tif (suspenseNode) suspenseNode.removeSuspense(node, customElement);\n\t\t\t\t});\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t__handleDynamicTag(currentValue, currentDependency, i, dynamics, values);\n\t\t\t}\n\t\t}\n\t}\n\treturn newValues;\n};\n\n/* \n================================================\nWOMPO COMPONENT DEFINITION\n================================================\n*/\n/**\n * This function will convert the functional component into an extension class of the HTMLElement,\n * so that it can be used to create the custom web-component.\n * @param Component The Component function\n * @param options The options of the component.\n * @returns A new dynamic class that will be used to create the custom web-component\n */\nconst _$wompo = <Props extends WompoProps, E>(\n\tComponent: WompoComponent,\n\toptions: WompoComponentOptions\n): WompoElementClass<Props, E> => {\n\tconst { generatedCSS, styles } = Component.options;\n\tconst sheet = new CSSStyleSheet();\n\tsheet.replaceSync(generatedCSS);\n\t/**\n\t * The dynamic class created to make it possible to create a custom web-component\n\t */\n\tconst WompoComponent = class extends HTMLElement implements WompoElement {\n\t\tstatic _$wompo = true; // For faster access\n\n\t\t/** The component name, used in the DOM */\n\t\tstatic componentName = options.name;\n\t\t/**\n\t\t * The cached template created in the first item's render, and then reused across all\n\t\t * components.\n\t\t */\n\t\tstatic _$cachedTemplate: CachedTemplate;\n\n\t\t/**\n\t\t * Get the already present cached template, or create a new one if the component is rendering\n\t\t * for the first time.\n\t\t * @param parts The template parts from the html function.\n\t\t * @returns The cached template.\n\t\t */\n\t\tstatic _$getOrCreateTemplate(html: RenderHtml) {\n\t\t\tif (!this._$cachedTemplate) this._$cachedTemplate = __createTemplate(html);\n\t\t\treturn this._$cachedTemplate;\n\t\t}\n\n\t\tpublic _$wompo: true = true; // For faster access\n\n\t\tpublic props: WompoProps = {};\n\t\tpublic hooks: Hook[] = [];\n\t\tpublic _$measurePerf: boolean = false;\n\t\tpublic _$initialProps: WompoProps = {} as any;\n\t\tpublic _$usesContext: boolean = false;\n\t\tpublic _$hasBeenMoved: boolean = false;\n\t\tpublic _$layoutEffects: EffectHook[] = [];\n\n\t\t/** The Root. It'll be the node itself, or it's ShadowRoot if shadow is set to true */\n\t\tprivate __ROOT: this | ShadowRoot;\n\t\t/** The array containing metadata of the component, used to render the component */\n\t\tprivate __dynamics: Dynamics[];\n\t\t/** It'll be true if the component has already processing an update. */\n\t\tprivate __updating: boolean = false;\n\t\t/** The array containing the dynamic values of the last render. */\n\t\tprivate __oldValues: any[] = [];\n\t\t/** It'll be true if the component is currently initializing. */\n\t\tprivate __isInitializing: boolean = true;\n\t\t/** It's true if the component is connected to the DOM. */\n\t\tprivate __connected: boolean = false;\n\t\t/** It's true if the component has been disconnected from the DOM. */\n\t\tprivate __disconnected: boolean = false;\n\t\t/**\n\t\t * Used to know if a component has been completely removed from the DOM or only temporarely to\n\t\t * move it from a node to another.\n\t\t */\n\t\tprivate __isInDOM: boolean = false;\n\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t}\n\n\t\t/** @override component has been connected to the DOM */\n\t\tconnectedCallback() {\n\t\t\t// If the element is disconnected and connected again, then execute again all effects.\n\t\t\tif (this.__disconnected && this.isConnected) {\n\t\t\t\tthis.__disconnected = false;\n\t\t\t\tfor (const hook of this.hooks) {\n\t\t\t\t\tif ((hook as EffectHook)?.callback) {\n\t\t\t\t\t\t// Effect hooks are executed again since the component has been connected again.\n\t\t\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\t\t\t(hook as EffectHook).callback();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.__isInDOM = true;\n\t\t\tif (!this.__connected && this.isConnected) this.__initElement();\n\t\t}\n\n\t\t/** @override component has been disconnected from the DOM */\n\t\tdisconnectedCallback() {\n\t\t\t// When a component is just \"moved\" to another element but not\n\t\t\t// removed from the DOM, it still calls the disconnected and\n\t\t\t// then the connected callback again. This prevents it.\n\t\t\tif (this.__connected) {\n\t\t\t\tthis.__isInDOM = false;\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\t// If the connectedCallback is called again, isInTheDOM will be true\n\t\t\t\t\tif (!this.__isInDOM) {\n\t\t\t\t\t\tthis.onDisconnected();\n\t\t\t\t\t\tthis.__disconnected = true;\n\t\t\t\t\t\tfor (const hook of this.hooks) {\n\t\t\t\t\t\t\tif ((hook as EffectHook)?.cleanupFunction) (hook as any).cleanupFunction();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._$hasBeenMoved = true;\n\t\t\t\t\t\tif (this._$usesContext) this.requestRender();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * This public callback will be used when a component is removed permanently from the DOM.\n\t\t * It allows other code to hook into the component and unmount listeners or similar when the\n\t\t * component is disconnected from the DOM.\n\t\t */\n\t\tpublic onDisconnected() {}\n\n\t\t/**\n\t\t * Initializes the component with the state, props, and styles.\n\t\t */\n\t\tprivate __initElement() {\n\t\t\tthis.__ROOT = this; // Shadow DOM is eventually attached later\n\t\t\tthis.props = {\n\t\t\t\t...this.props,\n\t\t\t\t...this._$initialProps,\n\t\t\t\tstyles: styles,\n\t\t\t} as any;\n\n\t\t\tconst componentAttributes = this.getAttributeNames();\n\t\t\tfor (const attrName of componentAttributes) {\n\t\t\t\tlet propName = attrName;\n\t\t\t\tif (propName.includes('-')) propName = propName.replace(/-(.)/g, (_, l) => l.toUpperCase());\n\t\t\t\tif (!this.props.hasOwnProperty(propName)) {\n\t\t\t\t\tconst attrValue = this.getAttribute(attrName);\n\t\t\t\t\t(this.props as any)[propName] = attrValue === '' ? true : attrValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set initialProps as attributes\n\t\t\tconst initialPropsKeys = Object.keys(this._$initialProps);\n\t\t\tfor (const key of initialPropsKeys) {\n\t\t\t\tconst prop = this._$initialProps[key as keyof typeof this._$initialProps];\n\t\t\t\tif (prop !== Object(prop) && (prop || (prop as any) === 0) && key !== 'title') {\n\t\t\t\t\tthis.setAttribute(\n\t\t\t\t\t\tkey.replace(/[A-Z]/g, (l) => `-${l.toLowerCase()}`),\n\t\t\t\t\t\tprop.toString()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (DEV_MODE && this.props.wcPerf) this._$measurePerf = true;\n\n\t\t\tif (DEV_MODE && this._$measurePerf) console.time('First render ' + options.name);\n\t\t\t// The children are saved in a WompoChildren instance, so that\n\t\t\t// they are not lost even when disconnected from the DOM.\n\t\t\tconst childNodes = this.__ROOT.childNodes;\n\t\t\tconst childrenArray: Node[] = [];\n\t\t\t// Removing items from the DOM doesn't delete them.\n\t\t\twhile (childNodes.length) {\n\t\t\t\tchildrenArray.push(childNodes[0]);\n\t\t\t\tchildNodes[0].remove();\n\t\t\t}\n\t\t\tconst children = new WompoChildren(childrenArray);\n\t\t\tthis.props.children = children;\n\n\t\t\t// Create shadow DOM\n\t\t\tif (options.shadow && !this.shadowRoot) this.__ROOT = this.attachShadow({ mode: 'open' });\n\n\t\t\tif (options.shadow) {\n\t\t\t\t(this.__ROOT as ShadowRoot).adoptedStyleSheets = [sheet];\n\t\t\t} else {\n\t\t\t\tconst root = this.getRootNode();\n\t\t\t\t(root as Document | ShadowRoot).adoptedStyleSheets.push(sheet);\n\t\t\t}\n\n\t\t\t// Render\n\t\t\tthis.__render();\n\n\t\t\tthis.__isInitializing = false;\n\t\t\tthis.__connected = true;\n\n\t\t\t// Observe attributes mutations\n\t\t\tnew MutationObserver((mutationRecords) => {\n\t\t\t\tif (!this.__updating) {\n\t\t\t\t\tmutationRecords.forEach((record) => {\n\t\t\t\t\t\tif (!mutationAttributesExclusions.includes(record.attributeName)) {\n\t\t\t\t\t\t\tlet propName = record.attributeName;\n\t\t\t\t\t\t\tif (propName.includes('-'))\n\t\t\t\t\t\t\t\tpropName = propName.replace(/-(.)/g, (_, l) => l.toUpperCase());\n\t\t\t\t\t\t\tthis.updateProp(propName, this.getAttribute(record.attributeName));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}).observe(this, { attributes: true });\n\n\t\t\tif (DEV_MODE && this._$measurePerf) console.timeEnd('First render ' + options.name);\n\t\t}\n\n\t\t/**\n\t\t * Calls the functional component by first setting correct values to the\n\t\t * [currentRenderingComponent] and [currentHookIndex] variables.\n\t\t * @returns The result of the call.\n\t\t */\n\t\tprivate __callComponent() {\n\t\t\tcurrentRenderingComponent = this;\n\t\t\tcurrentHookIndex = 0;\n\t\t\tconst result = Component.call(this, this.props);\n\t\t\tlet renderHtml: RenderHtml = result as RenderHtml;\n\t\t\tif (typeof result === 'string' || result instanceof HTMLElement) renderHtml = html`${result}`;\n\t\t\treturn renderHtml;\n\t\t}\n\n\t\t/**\n\t\t * Calls the component and executes the operations to update the DOM.\n\t\t */\n\t\tprivate __render() {\n\t\t\ttry {\n\t\t\t\tconst renderHtml = this.__callComponent();\n\t\t\t\tif (renderHtml === null || renderHtml === undefined) {\n\t\t\t\t\tthis.__dynamics = [];\n\t\t\t\t\tthis.__oldValues = [];\n\t\t\t\t\tthis.remove();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst constructor = this.constructor as typeof WompoComponent;\n\t\t\t\tif (this.__isInitializing) {\n\t\t\t\t\tconst template = constructor._$getOrCreateTemplate(renderHtml);\n\t\t\t\t\tconst [fragment, dynamics] = template.clone();\n\t\t\t\t\tthis.__dynamics = dynamics;\n\t\t\t\t\tconst elaboratedValues = __setValues(\n\t\t\t\t\t\tthis.__dynamics,\n\t\t\t\t\t\trenderHtml.values,\n\t\t\t\t\t\tthis.__oldValues\n\t\t\t\t\t);\n\t\t\t\t\tthis.__oldValues = elaboratedValues;\n\t\t\t\t\tif (!this.__isInitializing) this.__ROOT.innerHTML = '';\n\t\t\t\t\twhile (fragment.childNodes.length) {\n\t\t\t\t\t\tthis.__ROOT.appendChild(fragment.childNodes[0]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst oldValues = __setValues(this.__dynamics, renderHtml.values, this.__oldValues);\n\t\t\t\t\tthis.__oldValues = oldValues;\n\t\t\t\t}\n\t\t\t\twhile (this._$layoutEffects.length) {\n\t\t\t\t\tconst layoutEffectHook = this._$layoutEffects.pop();\n\t\t\t\t\tlayoutEffectHook.cleanupFunction = layoutEffectHook.callback();\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tconsole.error(err);\n\t\t\t\tif (DEV_MODE) {\n\t\t\t\t\tconst error = new WompoError.class();\n\t\t\t\t\t(error.props as WompoErrorProps).error = err;\n\t\t\t\t\t(error.props as WompoErrorProps).element = this;\n\t\t\t\t\tthis.__ROOT.innerHTML = '';\n\t\t\t\t\tthis.__ROOT.appendChild(error);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * It requests a render to the component. If the component has already received a render\n\t\t * request, the request will be rejected. This is to avoid multiple re-renders when it's not\n\t\t * necessary. The following function will cause a single re-render:\n\t\t * ```javascript\n\t\t * const incBy2 = () => {\n\t\t *   setState((oldState) => oldState + 1)\n\t\t *   setState((oldState) => oldState + 1)\n\t\t * }\n\t\t * ```\n\t\t */\n\t\tpublic requestRender() {\n\t\t\tif (!this.__updating) {\n\t\t\t\tthis.__updating = true;\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tif (DEV_MODE && this._$measurePerf) console.time('Re-render ' + options.name);\n\t\t\t\t\tthis.__render();\n\t\t\t\t\tthis.__updating = false;\n\t\t\t\t\tthis._$hasBeenMoved = false;\n\t\t\t\t\tif (DEV_MODE && this._$measurePerf) console.timeEnd('Re-render ' + options.name);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * It'll set a new value to a specific prop of the component, and a re-render will be requested.\n\t\t * @param prop The prop name.\n\t\t * @param value The new value to set.\n\t\t */\n\t\tpublic updateProp(prop: string, value: any) {\n\t\t\tif ((this.props as any)[prop] !== value) {\n\t\t\t\t(this.props as any)[prop] = value;\n\t\t\t\tif (!this.__isInitializing) {\n\t\t\t\t\tthis.requestRender();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\treturn WompoComponent as unknown as WompoElementClass<Props, E>;\n};\n\n/* \n================================================\nHOOKS\n================================================\n*/\n\n/**\n * This generic hook will allow the creation of custom hooks by exposing the current rendering\n * component and the current hook index. They will be returned in an array of 2 element:\n * [currentComponent, currentIndex].\n * The currentHookIndex will be then automatically incremented, so that the developer will not have\n * to worry about it, avoiding potential bugs.\n * @returns The current rendering component and current index.\n */\nexport const useHook = (): [WompoElement, number] => {\n\tconst currentComponent = currentRenderingComponent;\n\tconst currentIndex = currentHookIndex;\n\tconst res: [WompoElement, number] = [currentComponent, currentIndex];\n\tcurrentHookIndex++;\n\treturn res;\n};\n\n/**\n * This hook will allow a component to request a re-render when the property changes. It accepts one\n * parameter, which is the initial value, and it'll return an array containing 2 values: the current\n * value and a function to update it. The value will not be directly modifiable: it's necessary to\n * call the set function with the new value. The set function can be:\n *\n * 1. The new value\n * 2. A function that has the old state as a parameter, and returns the new value.\n *\n * The second case should be used in the following conditions:\n *\n * - Consecutive updates are performed consecutively\n * - The update is performed inside a callback function that is not re-created during render.\n *\n * If the state value is an object, to update it you must pass the whole object back: this hook will\n * not do a merge of the partial value and the old value. If you prefer this to happen, you should\n * apply the `useReducer` approach instead.\n *\n * @example\n * ```javascript\n * function Counter(){\n *   const [counter, setCounter] = useState(0);\n *   const inc = () => setCounter(counter+1);\n *   return html`<button \\@click=${inc}>${counter}</button>`;\n * }\n * ```\n *\n * @param defaultValue The starter value.\n * @returns The current StateHook value.\n */\nexport const useState = <S>(initialState: S | (() => S)) => {\n\tconst [component, hookIndex] = useHook();\n\tif (!component) {\n\t\t// Server context\n\t\tif (typeof initialState === 'function')\n\t\t\treturn [(initialState as () => S)(), () => {}] as StateHook<S>;\n\t\treturn [initialState, () => {}] as StateHook<S>;\n\t}\n\tif (!component.hooks.hasOwnProperty(hookIndex)) {\n\t\tconst index = hookIndex;\n\t\tcomponent.hooks[index] = [\n\t\t\ttypeof initialState === 'function' ? (initialState as () => S)() : initialState,\n\t\t\t(newValue: S) => {\n\t\t\t\tlet computedValue = newValue;\n\t\t\t\tconst stateHook = component.hooks[index] as StateHook<S>;\n\t\t\t\tif (typeof newValue === 'function') {\n\t\t\t\t\tcomputedValue = newValue(stateHook[0]);\n\t\t\t\t}\n\t\t\t\tif (computedValue !== stateHook[0]) {\n\t\t\t\t\tstateHook[0] = computedValue;\n\t\t\t\t\tcomponent.requestRender();\n\t\t\t\t}\n\t\t\t},\n\t\t];\n\t}\n\tconst state = component.hooks[hookIndex] as StateHook<S>;\n\treturn state;\n};\n\n/**\n * The useEffect hook allows to execute a callback (passed in the first argument) on first render\n * and whenever one of the dependencies changes (second argument). This is useful to execute async\n * calls, set intervals, and other types of initialization in the component.\n * The list of dependencies can be an empty array: in this case, the callback function will only be\n * executed once, that is after the first render.\n * The callback gets executed asynchronously, meaning that it'll be executed once the component will\n * finish its rendering phase.\n *\n * @example\n * ```javascript\n * function Timer(){\n *   const [time, setTime] = useState(0);\n *   useEffect(() => {\n *     setInterval(() => {\n *       setTime((oldTime) => oldTime + 1);\n *     }, 10)\n *   }, [])\n *   return html`Time: ${(time/100).toFixed(2)}s`\n * }\n * ```\n * @param callback The callback to execute when a dependency changes.\n * @param dependencies The list of dependencies to listen to changes.\n */\nexport const useEffect = (\n\tcallback: VoidFunction | (() => VoidFunction),\n\tdependencies: any[] = null\n) => {\n\tconst [component, hookIndex] = useHook();\n\tif (!component.hooks.hasOwnProperty(hookIndex)) {\n\t\tconst effectHook = {\n\t\t\tdependencies: dependencies,\n\t\t\tcallback: callback,\n\t\t\tcleanupFunction: null,\n\t\t} as EffectHook;\n\t\tcomponent.hooks[hookIndex] = effectHook;\n\t\tPromise.resolve().then(() => {\n\t\t\teffectHook.cleanupFunction = callback();\n\t\t});\n\t} else {\n\t\tconst componentEffect = component.hooks[hookIndex] as EffectHook;\n\t\tif (dependencies !== null) {\n\t\t\tfor (let i = 0; i < dependencies.length; i++) {\n\t\t\t\tconst oldDep = componentEffect.dependencies[i];\n\t\t\t\tif (oldDep !== dependencies[i]) {\n\t\t\t\t\tif (typeof componentEffect.cleanupFunction === 'function')\n\t\t\t\t\t\tcomponentEffect.cleanupFunction();\n\t\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\t\tcomponentEffect.cleanupFunction = callback();\n\t\t\t\t\t\tcomponentEffect.dependencies = dependencies;\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tcomponentEffect.cleanupFunction = callback();\n\t\t\t\tcomponentEffect.dependencies = dependencies;\n\t\t\t});\n\t\t}\n\t}\n};\n\n/**\n * The useLayoutEffect hook is the same as the main useEffect hook. The only difference stands in\n * the execution order: the useEffect hook gets executed asynchronously, so the component will first\n * render, and then it'll call the callback. The useLayoutEffect hook gets executed synchronously,\n * so `before` the component renders.\n * @param callback The callback to execute\n * @param dependencies The list of dependencies to listen to changes.\n */\nexport const useLayoutEffect = (\n\tcallback: VoidFunction | (() => VoidFunction),\n\tdependencies: any[] = null\n) => {\n\tconst [component, hookIndex] = useHook();\n\tif (!component.hooks.hasOwnProperty(hookIndex)) {\n\t\tconst effectHook = {\n\t\t\tdependencies: dependencies,\n\t\t\tcallback: callback,\n\t\t\tcleanupFunction: null,\n\t\t} as EffectHook;\n\t\tcomponent.hooks[hookIndex] = effectHook;\n\t\tcomponent._$layoutEffects.push(effectHook);\n\t} else {\n\t\tconst effectHook = component.hooks[hookIndex] as EffectHook;\n\t\tif (dependencies !== null) {\n\t\t\tfor (let i = 0; i < dependencies.length; i++) {\n\t\t\t\tconst oldDep = effectHook.dependencies[i];\n\t\t\t\tif (oldDep !== dependencies[i]) {\n\t\t\t\t\tif (typeof effectHook.cleanupFunction === 'function') effectHook.cleanupFunction();\n\t\t\t\t\teffectHook.dependencies = dependencies;\n\t\t\t\t\teffectHook.callback = callback;\n\t\t\t\t\tcomponent._$layoutEffects.push(effectHook);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tcomponent._$layoutEffects.push(effectHook);\n\t\t}\n\t}\n};\n\n/**\n * The useRef hook is very similar to the `useState` hook. The only difference is that the useRef\n * hook will NOT re-render the component, and the value will be accessed through the `.current`\n * property. This is useful if you want to keep a stable value of a variable across all the renders,\n * (without re-initializing the variable and loose it's previous state), but without causing a\n * re-render when the value changes.\n * If the value is passed to a \"ref\" attribute in any node, the .current value will be set to the\n * node having that attribute.\n *\n * @example\n * ```javascript\n * function Component(){\n *   const divRef = useRef();\n *   console.log(divRef.current); // null\n *   useEffect(() => {\n *     console.log(divRef.current); // HTMLDivElement\n *   }, []);\n *   return html`<div ref=${divRef}>I have a reference!</div>`;\n * }\n * ```\n *\n * @param initialValue The initial value.\n * @returns The current value of the reference.\n */\nexport const useRef = <T>(initialValue: T = null) => {\n\tconst [component, hookIndex] = useHook();\n\tif (!component.hooks.hasOwnProperty(hookIndex)) {\n\t\tcomponent.hooks[hookIndex] = {\n\t\t\tcurrent: initialValue,\n\t\t\t__wcRef: true,\n\t\t} as RefHook<T>;\n\t}\n\tconst ref = component.hooks[hookIndex] as RefHook<T>;\n\treturn ref;\n};\n\n/**\n * The useCallback hook is a useful hook that stores the given function and returns the same\n * function in the next renders.\n * Why is it useful? Because in javascript 2 function declarations are considered not equal:\n *\n * ```javascript\n * () => {} === () => {} // false\n *\n * const a = () => {}\n * a === a // true\n * ```\n *\n * So, for example, a useful case in which to use it, is when a callback function is passed through\n * the props of another component: if you don't use the `useCallback` hook, the child component will\n * re-render every time the parent component changes, because the two functions will be considered\n * different.\n * This consideration doesn't apply to events, because events are stored in a simple variable and\n * will not cause an add/removal of event listeners, so it's not computationally expensive: it's\n * more expensive to store the callback and get it back every time.\n *\n * @example\n * ```javascript\n * function Component(){\n *   const callback = useCallback(() => console.log('Hey!'));\n *   return html`<${NestedComponent} hey=${callback} />`\n * }\n * ```\n *\n * @param callbackFn The callback function to save.\n * @returns The stored callback function.\n */\nexport const useCallback = (callbackFn: (...args: any[]) => any, dependencies: any[] = []) => {\n\tconst [component, hookIndex] = useHook();\n\tif (!component.hooks.hasOwnProperty(hookIndex)) {\n\t\tcomponent.hooks[hookIndex] = {\n\t\t\tdependencies: dependencies,\n\t\t\tvalue: callbackFn,\n\t\t} as CallbackHook;\n\t} else {\n\t\tconst callbackHook = component.hooks[hookIndex] as CallbackHook;\n\t\tfor (let i = 0; i < dependencies.length; i++) {\n\t\t\tconst oldDep = callbackHook.dependencies[i];\n\t\t\tif (oldDep !== dependencies[i]) {\n\t\t\t\tcallbackHook.dependencies = dependencies;\n\t\t\t\tcallbackHook.value = callbackFn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tconst callback = component.hooks[hookIndex] as CallbackHook;\n\treturn callback.value;\n};\n\nconst useIdMemo = () => {\n\tlet counter = 0;\n\treturn () => {\n\t\tconst [component, hookIndex] = useHook();\n\t\tif (!component.hooks.hasOwnProperty(hookIndex)) {\n\t\t\tcomponent.hooks[hookIndex] = `:w${counter}:` as IdHook;\n\t\t\tcounter++;\n\t\t}\n\t\tconst callback = component.hooks[hookIndex];\n\t\treturn callback as IdHook;\n\t};\n};\n/**\n * The useId hook returns a unique id for the component. It's simply a counter that gets updated\n * every time a component instantiates this hook. The id structure will be the following: \":r0:\".\n *\n * Since the purpose of component is their reusability, a component should not have an element with\n * a static Id. That's when this function comes into play. The id can be used also for accessibility\n * purposes.\n *\n * @example\n * ```javascript\n * function Input(){\n *   const id = useId();\n *   return html`\n *     <input id=${id} type=\"checkbox\" />\n *     <label for=${id}>Input</label>\n *   `\n * }\n * ```\n *\n * @returns The useId hook.\n */\nexport const useId = useIdMemo();\n\n/**\n * The useMemo hook is useful when you want to store a computed value which would be expensive to\n * re-compute for every single render. For example, filtering or sorting, an array. It accepts one\n * callback function and will return the result of it. The second parameter contains the\n * dependencies that will cause the re-execution of the callback function when one of them changes.\n *\n * @example\n * ```javascript\n *\n * const users = [...] // thousands of users.\n *\n * function Users(){\n *   const adults = useMemo(() => {\n *     return users.filter(user => user.age >= 18);\n *   }, [users])\n *   return html`<ul>\n *     ${adults.map(user => html`<li>${user.name}</li>`)}\n *   </ul>`\n * }\n * ```\n *\n * @param callbackFn The callback function to execute.\n * @param dependencies The depencies to listen to changes.\n * @returns The last computed result.\n */\nexport const useMemo = <T>(callbackFn: () => T, dependencies: any[]) => {\n\tconst [component, hookIndex] = useHook();\n\tif (!component.hooks.hasOwnProperty(hookIndex)) {\n\t\tcomponent.hooks[hookIndex] = {\n\t\t\tvalue: callbackFn(),\n\t\t\tdependencies: dependencies,\n\t\t} as MemoHook<T>;\n\t} else {\n\t\tconst oldMemo = component.hooks[hookIndex] as MemoHook<T>;\n\t\tfor (let i = 0; i < dependencies.length; i++) {\n\t\t\tconst oldDep = oldMemo.dependencies[i];\n\t\t\tif (oldDep !== dependencies[i]) {\n\t\t\t\toldMemo.dependencies = dependencies;\n\t\t\t\toldMemo.value = callbackFn();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tconst memoizedResult = component.hooks[hookIndex] as MemoHook<T>;\n\treturn memoizedResult.value;\n};\n\n/**\n * The useReducer hook is an alternative approach for `useState`, using the redux-like state\n * management.\n * With this hook, you give as a parameter the initial state and the reducer function. This function\n * must accept 2 parameters: the old state, and the action, which is an object having at least the\n * \"type\" key (which is a string corresponding to the action to execute). The reducer must return\n * the new (partial) state.\n * The useReducer function will then return the current state and the **dispatch** function. This\n * function, unlike the simple set function generated by the `useState` hook, will accept a single\n * parameter which is the action to pass to the reducer function.\n *\n * @example\n * ```javascript\n * const reducer = (oldState, action) => {\n *   switch (action.type) {\n *     case 'ADD_SHEEP':\n *       return { sheeps: oldState.sheeps + 1 };\n *     case 'ADD_COW':\n *       return { cows: oldState.cows + 1 };\n *     default:\n *       throw new Error('Action not supported');\n *   }\n * }\n *\n * const initialState = { sheeps: 10, cows: 5 };\n *\n * function SheepsAndCows(){\n *   const [state, dispatch] = useReducer(initialState, reducer);\n *   const addSheep = () => dispatch({ type: 'ADD_SHEEP' })\n *   const addCow = () => dispatch({ type: 'ADD_COW' })\n *   return html`\n *     <button \\@click=${addSheep}>Sheeps: ${state.sheeps}</button>\n *     <button \\@click=${addCow}>Cows: ${state.cows}</button>\n *   `\n * }\n * ```\n *\n * @param reducer The reducer function.\n * @param initialState The initial state.\n * @returns An array with [state, dispath].\n */\nexport const useReducer = <State>(\n\treducer: (state: State, action: ReducerAction) => Partial<State>,\n\tinitialState: State\n) => {\n\tconst [component, hookIndex] = useHook();\n\tconst index = hookIndex;\n\tif (!component.hooks.hasOwnProperty(index)) {\n\t\tconst dispatch = (action: ReducerAction) => {\n\t\t\tconst currentState = (component.hooks[index] as ReducerHook<State>)[0];\n\t\t\tconst partialState = reducer(currentState, action);\n\t\t\tlet newState: State = partialState as State;\n\t\t\tif (\n\t\t\t\ttypeof currentState === 'object' &&\n\t\t\t\t!Array.isArray(currentState) &&\n\t\t\t\tcurrentState !== null\n\t\t\t) {\n\t\t\t\t// Merge the partial state with the old one if it's an object\n\t\t\t\tnewState = {\n\t\t\t\t\t...currentState,\n\t\t\t\t\t...partialState,\n\t\t\t\t} as State;\n\t\t\t}\n\t\t\t(component.hooks[hookIndex] as ReducerHook<State>)[0] = newState;\n\t\t\tif (newState !== currentState) component.requestRender();\n\t\t};\n\t\tconst reducerHook: ReducerHook<State> = [initialState, dispatch];\n\t\tcomponent.hooks[hookIndex] = reducerHook;\n\t}\n\tconst stateAndReducer = component.hooks[hookIndex] as ReducerHook<State>;\n\treturn stateAndReducer;\n};\n\n/**\n * The useExposed hook allows the component to expose variables and/or methods in the DOM. Sometimes\n * you want to be able to select an element in the DOM and then use one of it's methods to do some\n * kind of operations. Some components are better to have an \"isolated\" state, meaning that it's\n * rendering state should be internal, and not depending to its props. A nice example it's a modal:\n * you'd rather want to have an `open()` method that having an `open` property, that causes a\n * re-render of the parent and the modal component.\n *\n * This is a different approach compared to React, but using exposed methods in custom elements can\n * have great benefits speaking about performances in comparison of using props to manage the state.\n *\n * This hook accepts an object having as keys the name of the property to expose and the\n * corresponding values.\n * The `useExposed` hook is a great combination with the `useRef` hook.\n *\n * @example\n * ```javascript\n * function Modal(){\n *   const [open, setOpen] = useState(false);\n *   const openModal = () => setOpen(true);\n *   const closeModal = () => setOpen(false);\n *   useExposed({\n *     open: openModal,\n *     close: closeModal,\n *   });\n *   return html`...`;\n * }\n *\n * function ParentComponent(){\n *   const modalRef = useRef();\n *   /// Will only re-render the modal component, and not this component.\n *   const openModal = () => modalRef.current.open();\n *   return html`\n *     <button \\@click=${openModal}>Open Modal</button>\n *     <${Modal} ref=${modalRef} />\n *   `\n * }\n * ```\n *\n * @param toExpose The keys to expose.\n */\nexport const useExposed = <E = {}>(toExpose: E) => {\n\t// No need to use useHook and increase the hook index\n\tconst component = currentRenderingComponent;\n\tconst keys = Object.keys(toExpose) as (keyof E)[];\n\tfor (const key of keys) {\n\t\t(component as any)[key] = toExpose[key];\n\t}\n};\n\n/**\n * Executes the callback function in the useAsync hook.\n * @param hook The hook data.\n * @param suspense The (maybe) parent suspense.\n * @param callback The callback function that returns the promise.\n */\nconst executeUseAsyncCallback = <S>(\n\thook: [WompoElement, number],\n\tsuspense: SuspenseInstance,\n\tcallback: () => Promise<S>\n) => {\n\tconst [component, hookIndex] = hook;\n\tif (suspense) {\n\t\tsuspense.addSuspense(component);\n\t}\n\t(component.hooks[hookIndex] as AsyncHook<S>).value = null;\n\tconst promise = callback();\n\tpromise\n\t\t.then((data) => {\n\t\t\tcomponent.requestRender();\n\t\t\tsuspense?.removeSuspense(component);\n\t\t\t(component.hooks[hookIndex] as AsyncHook<S>).value = data;\n\t\t})\n\t\t.catch((err) => console.error(err));\n};\n\n/**\n * The `useAsync` hook allows to resolve a promise. It accepts a callback and a list of dependencies\n * as parameters. The callback must return a promise and will be executed on first render and\n * whenever one of the dependencies changes.\n * The hook will return `null` if the promise is being resolved, otherwise the result of the\n * promise. The component will be automatically re-rendered once the promise is resolved.\n *\n * It can be used with a parent `Suspanse` instance to show a loading indicator while the promise\n * is being resolved.\n *\n * @example\n * ```javascript\n * const callback = async () => {\n *   return new Promise((resolve) => { setTimeout(() => { resolve('Solved!'); }, 5000); });\n * }\n *\n * function Results() {\n *   const data = useAsync(callback, []);\n *   return html`${data}`;\n * }\n *\n * function App(){\n *   return html`<${Suspanse} fallback=${html`Loading...`}>\n *     <${Results} />\n *   </${Suspanse}>`\n * }\n * ```\n * @param promise The promise to resolve.\n * @returns The result of the promise or null if it's pending or rejected.\n */\nexport const useAsync = <S>(callback: () => Promise<S>, dependencies: any[]): null | S => {\n\tconst [component, hookIndex] = useHook();\n\tconst suspense = findSuspense(component);\n\tif (!component.hooks.hasOwnProperty(hookIndex)) {\n\t\tcomponent.hooks[hookIndex] = {\n\t\t\tdependencies: dependencies,\n\t\t\tvalue: null,\n\t\t} as AsyncHook<S>;\n\t\texecuteUseAsyncCallback([component, hookIndex], suspense, callback);\n\t} else {\n\t\tconst oldAsync = component.hooks[hookIndex] as AsyncHook<S>;\n\t\tlet newCall = false;\n\t\tfor (let i = 0; i < dependencies.length; i++) {\n\t\t\tconst oldDep = oldAsync.dependencies[i];\n\t\t\tif (oldDep !== dependencies[i]) {\n\t\t\t\toldAsync.dependencies = dependencies;\n\t\t\t\tnewCall = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (newCall) {\n\t\t\texecuteUseAsyncCallback([component, hookIndex], suspense, callback);\n\t\t}\n\t}\n\treturn (component.hooks[hookIndex] as AsyncHook<S>).value;\n};\n\n//? NO useDebugValue (because is for react-dev-tools)\n//? NO useDeferredValue\n//? NO useImperativeHandle\n//? NO useInsertionEffect\n//? NO useOptimistic\n\n/* \n================================================\nCONTEXT\n================================================\n*/\n\n/**\n * The Context interface\n */\nexport interface Context<S = any> {\n\tProvider: WompoComponent<ContextProviderProps>;\n\tdefault: S;\n\tname: string;\n}\n\nconst createContextMemo = () => {\n\tlet contextIdentifier = 0;\n\treturn <S>(initialValue: S, providerName?: string): Context<S> => {\n\t\tconst name = providerName ?? `wompo-context-provider-${contextIdentifier}`;\n\t\tcontextIdentifier++;\n\t\tconst ProviderFunction = defineWompo<ContextProviderProps, ContextProviderExposed>(\n\t\t\t({ children }: ContextProviderProps) => {\n\t\t\t\tconst initialSubscribers = new Set<WompoElement>();\n\t\t\t\tconst subscribers = useRef(initialSubscribers);\n\t\t\t\tuseExposed({ subscribers: subscribers });\n\t\t\t\tsubscribers.current.forEach((el) => el.requestRender());\n\t\t\t\treturn html`${children}`;\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: name,\n\t\t\t\tcssModule: false,\n\t\t\t}\n\t\t);\n\t\tconst Context = {\n\t\t\tname: name,\n\t\t\tProvider: ProviderFunction,\n\t\t\tdefault: initialValue,\n\t\t\tsubscribers: new Set<WompoElement>(),\n\t\t};\n\t\treturn Context;\n\t};\n};\n\n/**\n * The createContext function returns a Context instance that can be used to pass down a property\n * to all its children. This can be quite useful to avoid passing down props infinitely.\n * The function accepts a single parameter, that is the default value that will be used if a\n * component requires a context that does't have a parent providing the requested value.\n *\n * To initialize the component you'll have to put in the DOM the Context.Provider instance, which\n * accepts a single prop: value. This value will then be passed down to the components that use the\n * `useContext` hook.\n *\n * @example\n * ```javascript\n * const ThemeContext = createContext('light');\n *\n * function App(){\n *   const [theme, setTheme] = useState('light');\n *   const toggle = () => {\n *     if(theme === 'light') setTheme('dark');\n *     if(theme === 'dark') setTheme('light');\n *   }\n *   return html`\n *     <button \\@click=${toggle}>Toggle Theme</button>\n *     <${ThemeContext.Provider} value=${theme}>\n *       <${CompWithTheme} />\n *     </${ThemeContext.Provider}>\n *   `;\n * }\n *\n * function CompWithTheme(){\n *   const theme = useContext(ThemeContext);\n *   return html`<p>Current Theme: ${theme}.</p>`;\n * }\n * ```\n */\nexport const createContext = createContextMemo();\n\n/**\n * The useContext hook is used to obtain the current value provided bya a parent Context.Provider\n * element. The context must be created first with the `createContext` function.\n * @param Context The context to use.\n * @returns The value of the context above the element.\n */\nexport const useContext = <S>(Context: Context<S>): S => {\n\tconst [component, hookIndex] = useHook();\n\tcomponent._$usesContext = true;\n\tif (!component.hooks.hasOwnProperty(hookIndex) || component._$hasBeenMoved) {\n\t\tlet parent = component as Node;\n\t\tconst toFind = Context.name.toUpperCase();\n\t\twhile (parent && parent.nodeName !== toFind && parent !== document.body) {\n\t\t\tif (parent instanceof ShadowRoot) parent = parent.host;\n\t\t\telse parent = parent.parentNode;\n\t\t}\n\t\tconst oldParent = (component.hooks[hookIndex] as ContextHook)?.node;\n\t\tif (parent && parent !== document.body) {\n\t\t\t(parent as ContextProviderElement).subscribers.current.add(component);\n\t\t\tconst oldDisconnect = component.onDisconnected;\n\t\t\tcomponent.onDisconnected = () => {\n\t\t\t\t(parent as ContextProviderElement).subscribers.current.delete(component);\n\t\t\t\toldDisconnect();\n\t\t\t};\n\t\t} else if (oldParent) {\n\t\t\tif (DEV_MODE) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`The element ${component.tagName} doens't have access to the Context ${Context.name} ` +\n\t\t\t\t\t\t'because is no longer a child of it.'\n\t\t\t\t);\n\t\t\t}\n\t\t\tparent = null;\n\t\t\toldParent.subscribers.current.delete(component);\n\t\t} else if (component.isConnected) {\n\t\t\tconsole.warn(\n\t\t\t\t`The element ${component.tagName} doens't have access to the Context ${Context.name}. ` +\n\t\t\t\t\t'The default value will be returned instead.'\n\t\t\t);\n\t\t\tparent = null;\n\t\t}\n\t\tcomponent.hooks[hookIndex] = {\n\t\t\tnode: parent,\n\t\t} as ContextHook;\n\t}\n\tconst contextNode = (component.hooks[hookIndex] as ContextHook).node;\n\treturn contextNode ? contextNode.props.value : Context.default;\n};\n\n/* \n================================================\nHTML\n================================================\n*/\n\n/**\n * This template function is used to then generate the DOM structure for a component.\n * Should be used as a return value for every component, and for every string value that contains\n * an HTML structure. Simple strings will be taken as they are, and will not be converted into HTML\n * nodes.\n *\n * @example\n * ```javascript\n * const greeting = 'Hello, world!';\n * const template = html`<div>${greeting}</div>`\n * ```\n * @param template The list of static strings of the template\n * @param values The list of dynamic values of the template\n */\nexport function html(templateParts: TemplateStringsArray, ...values: any[]): RenderHtml {\n\tconst cleanValues = [];\n\tconst length = templateParts.length - 1; // skip last element\n\tif (!IS_SERVER) {\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\t// Don't include dynamic closing tags\n\t\t\tif (!templateParts[i].endsWith('</')) cleanValues.push(values[i]);\n\t\t}\n\t} else {\n\t\tcleanValues.push(...values);\n\t}\n\treturn {\n\t\tparts: templateParts,\n\t\tvalues: cleanValues,\n\t\t_$wompoHtml: true,\n\t};\n}\n\n/* \n================================================\nDEFAULT OPTIONS\n================================================\n*/\n/**\n * The default options used when creating a Web Component. If you customize these options, you\n * should do it at the TOP of your html file, before every other component renders.\n * The current options are:\n * - `shadow`: false (boolean)\n * - `cssModule`: true (boolean)\n */\nexport const wompoDefaultOptions: WompoComponentOptions = {\n\tshadow: false,\n\tname: '',\n\tcssModule: true,\n};\n\n/* \n================================================\nDEFINE WOMPO COMPONENT\n================================================\n*/\nexport const registeredComponents: { [key: string]: WompoComponent } = {};\n/**\n * The defineWompo function will be the trigger point to generate your custom web component.\n * It accepts 2 parameter: your functional component and the options to customize it.\n * The current available options are the followings:\n * - `name` (string)\n * - `shadow` (boolean).\n * - `cssModule` (boolean)\n *\n * The default values will depend on the [wompoDefaultOptions] variable.\n *\n * The functional component can have the css property, wich is a string corresponding to its styles.\n *\n * The `name` of the component will be the one specified in the options, or, if not specified, will\n * be the hyphen-cased name of the functional component. If the generated name will not have at\n * least one hyphen, a \"-wompo\" string will be appended in the end.\n * Example: function CounterComponent(){} -> counter-component\n * Example2: function Counter(){} -> counter-wompo\n *\n * The `shadow` option, if true, will build the content of the component in a Shadow DOM.\n *\n * The `cssModule` option will transform the css of the component by replacing the classes with\n * unique names, that will then be passed in the `styles` props of the component.\n *\n * @example\n * ```javascript\n * function Greetings(){\n *   return html`<p>Hello World!</p>`\n * }\n * Greetings.css = `p { color: blue; }`\n *\n * export default defineWompo(Greetings, {\n *   name: 'greetings-component',\n *   shadow: true,\n * })\n * ```\n *\n * @param component The functional component.\n * @param options The options of the component.\n * @returns The generated class for the component.\n */\nexport function defineWompo<Props extends WompoProps, E = {}>(\n\tComponent: WompoComponent<Props & WompoProps>,\n\toptions?: WompoComponentOptions\n) {\n\tif (!Component.css) Component.css = '';\n\tconst componentOptions = {\n\t\t...wompoDefaultOptions,\n\t\t...(options || {}),\n\t};\n\tif (!componentOptions.name) {\n\t\tlet newName = Component.name\n\t\t\t.replace(/.[A-Z]/g, (letter) => `${letter[0]}-${letter[1].toLowerCase()}`)\n\t\t\t.toLowerCase();\n\t\tif (!newName.includes('-')) newName += '-wompo';\n\t\tcomponentOptions.name = newName;\n\t}\n\tComponent.componentName = componentOptions.name;\n\tComponent._$wompoF = true;\n\tconst [generatedCSS, styles] = __generateSpecifcStyles(Component, componentOptions);\n\tComponent.css = generatedCSS;\n\tComponent.options = {\n\t\tgeneratedCSS: generatedCSS,\n\t\tstyles: styles,\n\t\tshadow: componentOptions.shadow,\n\t};\n\tif (!IS_SERVER) {\n\t\tconst ComponentClass = _$wompo<Props, E>(Component, componentOptions);\n\t\tComponent.class = ComponentClass;\n\t\tcustomElements.define(componentOptions.name, ComponentClass);\n\t}\n\tregisteredComponents[componentOptions.name] = Component;\n\treturn Component as WompoComponent<Props & WompoProps>;\n}\n\n/* \n================================================\nMETHODS\n================================================\n*/\n\nexport type LazyCallbackResult = Promise<{ default: WompoComponent }>;\nexport type LazyResult = {\n\t(): Promise<WompoComponent<WompoProps>>;\n\t_$wompoLazy: boolean;\n};\n\n/**\n * The lazy function allows to asynchronously import a component. The load function will be executed\n * only when the component is used, and the result will be cached so that for the next times it'll\n * always return the loaded component. The lazy component can then be combined with the `Suspense`\n * component to render a loading interface while the lazy component is loading.\n *\n * @example\n * ```javascript\n * const DynamicallyLoadedComponent = lazy(() => import('./super-big-component.js'));\n *\n * function App(){\n *   return html`\n *     <${Suspense} fallback=${html`<i>Loading...</i>`}>\n *       <${DynamicallyLoadedComponent} />\n *     </${Suspense}>\n *   `\n * }\n * ```\n * @param load The callback that loads the component\n * @returns A LazyComponent or the loaded compnent\n */\nexport const lazy = (load: () => LazyCallbackResult): LazyResult => {\n\tlet loaded: WompoComponent = null;\n\tasync function LazyComponent() {\n\t\tif (!loaded) {\n\t\t\ttry {\n\t\t\t\tconst importedModule = await load();\n\t\t\t\tloaded = importedModule.default;\n\t\t\t\treturn loaded;\n\t\t\t} catch (err) {\n\t\t\t\tconsole.error(err);\n\t\t\t\treturn WompoError;\n\t\t\t}\n\t\t}\n\t\treturn loaded;\n\t}\n\tLazyComponent._$wompoLazy = true;\n\treturn LazyComponent;\n};\n\ninterface SuspenseProps extends WompoProps {\n\tfallback: RenderHtml;\n}\ninterface SuspenseInstance extends WompoElement {\n\tloadingComponents: Set<Node>;\n\t/**\n\t * Adds a node to the Suspense instance, and re-render.\n\t * @param node The node that is suspended.\n\t */\n\taddSuspense: (node: Node) => void;\n\t/**\n\t * Remove a node from the Suspense instance. If the node is a new Node (e.g. a dynamic Tag),\n\t * you should also add the second parameter (the new node).\n\t * @param node The node that is suspended.\n\t * @param newNode The new node to replace the old one with.\n\t */\n\tremoveSuspense: (node: Node, newNode?: Node) => void;\n}\n\n/**\n * Finds the closest Suspanse parent node and returns it. If the [startNode] has not parent Suspanse\n * instances, it'll return null.\n * @param startNode The node (possibly a chil of a Suspanse instance).\n * @returns The Found Suspanse instance or null.\n */\nconst findSuspense = (startNode: Node): SuspenseInstance | null => {\n\tlet suspense = startNode;\n\twhile (\n\t\tsuspense &&\n\t\tsuspense.nodeName !== (Suspense as WompoComponent).componentName.toUpperCase()\n\t) {\n\t\tif (suspense.parentNode === null && (suspense as ShadowRoot).host)\n\t\t\tsuspense = (suspense as ShadowRoot).host;\n\t\telse suspense = suspense?.parentNode;\n\t}\n\treturn suspense as SuspenseInstance | null;\n};\n\n/* \n================================================\nCOMPONENTS\n================================================\n*/\ninterface WompoErrorProps extends WompoProps {\n\terror: any;\n\telement: WompoElement;\n}\n\nlet WompoError: WompoComponent;\nif (DEV_MODE) {\n\tWompoError = function ({ styles: s, error, element }: WompoErrorProps) {\n\t\tlet content;\n\t\tif (element && error) {\n\t\t\tcontent = html`<div>\n\t\t\t\t<p>An error rised while rendering the element \"${element.nodeName.toLowerCase()}\".</p>\n\t\t\t\t<p>${error.stack.split('\\n').map((row: string) => html`${row}<br />`)}</p>\n\t\t\t</div>`;\n\t\t} else {\n\t\t\tcontent = html`<div>\n\t\t\t\t<p>An error rised while rendering. Check the developer console for more details.</p>\n\t\t\t</div>`;\n\t\t}\n\t\treturn html`${content}`;\n\t} as any;\n\tWompoError.css = `\n\t\t:host {\n\t\t\tdisplay: block;\n\t\t\tpadding: 20px;\n\t\t\tbackground-color: #ffd0cf;\n\t\t\tcolor: #a44040;\n\t\t\tmargin: 20px;\n\t\t\tborder-left: 3px solid #a44040;\n\t\t}\n\t`;\n\tdefineWompo(WompoError, { name: 'wompo-error', shadow: true });\n}\n\n/**\n * The Suspense component is used to render a Loading UI while its children are still being rendered\n * because they are lazy or because one of its children has a deferred value that is being updated.\n *\n * @example\n * ```javascript\n * const DynamicallyLoadedComponent = lazy(() => import('./super-big-component.js'));\n *\n * function App(){\n *   return html`\n *     <${Suspense} fallback=${html`<i>Loading...</i>`}>\n *       <${DynamicallyLoadedComponent} />\n *     </${Suspense}>\n *   `\n * }\n * ```\n * @param props Accepts children and a Fallback component.\n * @returns The Fallback if loading, otherwise the loaded content.\n */\nexport function Suspense({ children, fallback }: SuspenseProps) {\n\tif (!this.loadingComponents) {\n\t\tthis.loadingComponents = useRef(new Set<Node>()).current;\n\t}\n\tthis.addSuspense = (node: Node) => {\n\t\tif (!this.loadingComponents.size) this.requestRender();\n\t\tthis.loadingComponents.add(node);\n\t};\n\tthis.removeSuspense = (node: Node, newNode: Node = null) => {\n\t\tthis.loadingComponents.delete(node);\n\t\tif (newNode) {\n\t\t\tfor (let i = 0; i < children.nodes.length; i++) {\n\t\t\t\tif (children.nodes[i] === node) {\n\t\t\t\t\tchildren.nodes[i] = newNode;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!this.loadingComponents.size) this.requestRender();\n\t};\n\tif (this.loadingComponents.size) return html`${fallback}`;\n\treturn html`${children}`;\n}\ndefineWompo(Suspense, {\n\tname: 'wompo-suspense',\n});\n\n// TODO Add ErrorBoundary component\n// TODO Handle DEV_MODE based on Production or Development environment\n"],
  "mappings": "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",
  "names": ["DEV_MODE", "currentRenderingComponent", "currentHookIndex", "WC_MARKER", "DYNAMIC_TAG_MARKER", "isDynamicTagRegex", "isAttrRegex", "selfClosingRegex", "isInsideTextTag", "onlyTextChildrenElementsRegex", "NODE", "ATTR", "TAG", "IS_SERVER", "doc", "treeWalker", "mutationAttributesExclusions", "CachedTemplate", "template", "dependencies", "content", "fragment", "node", "nodeIndex", "dynamicIndex", "templateDependency", "dynamics", "dynamic", "type", "DynamicNode", "DynamicAttribute", "DynamicTag", "HtmlProcessedValue", "render", "startNode", "endNode", "currentNode", "dependency", "newValue", "isWompoElement", "isPrimitive", "styleString", "styles", "key", "styleValue", "styleKey", "letter", "callback", "eventName", "event", "WompoChildren", "nodes", "WompoArrayDependency", "values", "toAdd", "i", "value", "__setValues", "newValues", "oldValuesLength", "diff", "toClean", "oldValue", "__generateSpecifcStyles", "component", "options", "css", "shadow", "name", "cssModule", "componentName", "classes", "generatedCss", "_", "className", "uniqueClassName", "__createHtml", "parts", "html", "attributes", "length", "attrDelimiter", "textTagName", "part", "isAttr", "match", "attrName", "beforeLastChar", "delimiter", "el", "insideTextTag", "firstPart", "attr", "__createDependencies", "dependencyIndex", "partsLength", "attributeNames", "realName", "attrValue", "dynamicParts", "strings", "lastIndex", "__createTemplate", "dom", "__areSameTemplates", "newTemplate", "oldTemplate", "newParts", "oldParts", "oldValues", "__shouldUpdate", "currentValue", "valuesDiffers", "isComposedAttribute", "childrenNeedUpdate", "__handleDynamicTag", "currentDependency", "valueIndex", "customElement", "isCustomComponent", "newNodeName", "oldAttributes", "initialProps", "propName", "l", "childNodes", "index", "currentDynamic", "areTheSame", "oldTemplateValue", "processedValues", "oldIsPrimitive", "newNodeIndex", "childrenNodes", "newNode", "attrStructure", "dynamicValue", "j", "suspenseNode", "findSuspense", "Component", "_$wompo", "generatedCSS", "sheet", "hook", "componentAttributes", "initialPropsKeys", "prop", "childrenArray", "children", "mutationRecords", "record", "result", "renderHtml", "constructor", "elaboratedValues", "layoutEffectHook", "err", "res", "initialState", "hookIndex", "computedValue", "stateHook", "componentEffect", "effectHook", "initialValue", "callbackFn", "callbackHook", "useIdMemo", "counter", "oldMemo", "reducer", "reducerHook", "action", "currentState", "partialState", "newState", "toExpose", "keys", "executeUseAsyncCallback", "suspense", "data", "oldAsync", "newCall", "createContextMemo", "contextIdentifier", "providerName", "ProviderFunction", "subscribers", "Context", "parent", "toFind", "oldParent", "oldDisconnect", "contextNode", "templateParts", "cleanValues", "componentOptions", "newName", "ComponentClass", "load", "loaded", "LazyComponent", "WompoError", "fallback"]
}
